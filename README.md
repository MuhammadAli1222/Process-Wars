# Process Wars

----
## What is this?
* Process wars is an exercise in synchronization written in C.
* It is essentially a turn-based game where the main process keeps track of a number of "warring" forked processes, which each have soldiers and fighters. In-depth instructions [here](https://www.pdf-archive.com/2017/12/01/process-wars/).
* Each turn, each process randomly selects another process to attack. This has to be communicated to the main process
*  The attack points are generated by each soldier after it consumes a resource. Resources are produced by farmers, but at most *6 farmers can be awake at any one time*. The awoken farmers produce a resource point after a random 400-2000ms waiting period.
* Damage received from an attack is received by soldiers. Each soldier has 3 health points, and dies after it loses the 3 health points. 
* A process has "lost" after all its soldiers are dead.

----
## Usage
1. Compile like so: `gcc -pthread -lrt -Wall -Werror war.c`
2. Run the executable specifying the number of children and number of fighters like so: `./a.out -children 5 -fighters 5`

----
##Synchronization

---
### FIFO Communication
* The master process has to communicate with each of its children in order to get information about the attacked and attacked PID.
* I use a named pipe to facilitate this communication.
* To make sure that the communication is synchronized, l used 2 named semaphores to control communication between the processes (`pipe_read` and `pipe_write` variables). 
* I initialize this variable in line lines 343 and 344. The read semaphore has 0 tokens to begin with and the write has 1 token. I later open each named semaphore in each child process again (line 403 and 404).
* I use the semaphores to make sure there is something to read in the first place when main process reads from FIFO. In line 564, `sem_wait(pipe_read);` means that the main process has to wait for the a writing process to post a read token before it can proceed. Initially there are 0 token for the pipe_read semaphore, so this process cannot proceed *unless* some writer process first posts a token to `pipe read`.
* In each writing child process, this happens(lines 494-496):

---    

    sem_wait(pipe_write); //takes one token from the write semaphore.
    /*write stuff*/
    sem_post(pipe_read); //releases token for the reader to read

* Same thing happens with the reader. It waits for `pipe_read` and posts a token to `pipe_write`.

---
### Mutex for Resource Object 
* In order to ensure that the access to resource array is synchronized, I use a mutex `thread_mutex` to lock and unlock threads.
* Malloced in line 391. I chose to allocate the space on heap to ensure that the mutex will be shared by all the threads (since they have share the heap).
* See `farmer_routine` and `soldier_routine` (line 53 and 98) for its use. Everytime I access the `resource` array I make sure to lock and unlock.

---
### Semaphore for 6 Farmers 
* Semaphore `sem` used to ensure that only 6 farmers at a time are active. 
* Initialized with 6 tokens (see line 410).
* See `farmer_routine` (line 53) for its use. 



